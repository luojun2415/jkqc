<extend name="Public/base"/><block name="body">	<div class="col-xs-12">    <div class="col-xs-6 main-title" style="PADDING: 0;">		<h2 style="margin: 0;padding: 0;height: 50px;line-height: 50px;">户型图绘制</h2>    </div>    <div class="col-xs-6" style="    float: right;height: 50px;line-height: 50px;text-align: right;border-bottom: 1px solid #CCC;"><!--    <a href="javascript:xiangqing('{$room_id}')">预览</a>  -->    <a href="#" onclick="javascript:history.back(-1);return false;" style="background: #36c6d3;COLOR: #FFF;PADDING: 5px 20px;border-radius: 5px !important;">返回</a>    </div>	<div style="padding:0 30px;">		<div class="col-xs-12">			<div class="col-xs-6" style="line-height: 32px;">户型图名称： {$data.title}  {$data.remark} </div>			<div class="oneselect">				<div class="title">功能区选择：</div>				<div class="select_box">					<select id="types" name="type" data-role="select_text" class="form-control">						<option value="0">请选择</option>						<volist name="_types" id="vo">							<option value="{$vo.id}">{$vo.title}</option>						</volist>					</select>				</div>			</div>		</div>	<div class="col-xs-12 invoice-content-2 bordered" style=" margin-top: 10px;border:1px solid #C6C6C6;">		<div class="col-xs-12">		<span>户型绘制区域</span>		</div>		<div class="col-xs-12" id="area" style="text-align: center;    position: relative;">			<canvas id="myCanvas" width="800" height="600" style="position: absolute;"  onclick="drawScreen()"  > Your browser does not support HTML5 Canvas. </canvas>			<img id="img_src" style="margin: 0 auto;width: 800px;height: 600px;" src="{$data.path}" />		</div>   </div>	</div>       <input type="hidden" id="id" value="{$data.id}" />		<input type="hidden" id="mid" value="{$data.mid}" />	<div class="col-xs-12" style="text-align: center;margin: 10px;">		<a href="#" id="ok-btn" onclick="startDraw()" class="btn btn-ajax btn-success btn">开始绘制</a>		<a href="#" id="reset" onclick="resetDraw()"  class="btn btn-ajax btn-danger btn">重置</a>	</div>	</div></block><block name="script">	<script type="text/javascript">		var ctx,obj ;		var flag=testflag=0;//开始绘制标志        // var left = document.getElementById('img_src').offsetLeft;		$(function () {            // var width = $('#img_src').width();            // var height = $('#img_src').height();            // $('#myCanvas').css('width',width);            // $('#myCanvas').css('height',height);            // $('#myCanvas').css('left',left+'px');            // $('#area').css('height',height);            canvasApp();        });		function test() {            testflag=!testflag;        }		function startDraw() {		    var type=$('#types').val();		    if(type==0){                updateAlert('请先选择要绘制的功能区。','danger');                return false;			}			if (0==flag){			    flag=1;			    $('#ok-btn').text('保存');			}			else{                saveDraw();                points=new Array();                startPoint=tmpPoint={};                flag=0;			}        }        function saveDraw() {		    if(points.length<=3){                updateAlert('绘制功能区需要3个点位以上。','danger');                return false;			}            ctx.beginPath();            ctx.moveTo(tmpPoint.x, tmpPoint.y);            ctx.lineTo(startPoint.x, startPoint.y);            ctx.stroke();            ctx.closePath();            ctx.font="15px Georgia";            ctx.fillStyle = "Red";            var txt = $('#types').find("option:selected").text();            fdrawTxt(points,txt);            console.log(points.join(','));            var url = "{:U('Tenement/house_detail')}";            var id = $('#id').val();            var mid = $('#mid').val();            var tid = $('#types').val();            var data = {'points':points,'id':id,'mid':mid,'tid':tid};            $('#ok-btn').attr("disabled","disabled");            $.post(url, data, function (msg) {                $('#ok-btn').removeAttr("disabled");                if(msg.status==1){                    flag=0;                    $('#ok-btn').text('开始绘制');                    updateAlert(msg.info,'success');				}				else{                    updateAlert(msg.info,'danger');				}            });        }        //在多边形中绘制文字		function fdrawTxt(points,txt) {            ctx.font="15px Georgia";            ctx.fillStyle = "Red";            var x = points[2].x-points[0].x;            var y = points[1].y-points[0].y;            console.log(x+','+y);            x=points[0].x+x/2;            y=points[0].y+y/2;            x=x.toFixed(2);            y=y.toFixed(2);            console.log(points[0].x+','+points[0].y);            console.log(x+','+y);            ctx.fillText(txt,x,y);        }        function resetDraw() {            ctx.clearRect(0,0,myCanvas.width,myCanvas.height);            startPoint=tmpPoint='';        }        var myCanvas = document.getElementById('myCanvas');        ctx = myCanvas.getContext('2d');        function canvasSupport (e) {            return !!e.getContext;        }        function canvasApp () {            if (!canvasSupport(myCanvas)) {                return;            }            ctx.strokeStyle = 'red';            ctx.lineWidth = 3;            obj=ctx;        }        var startPoint,tmpPoint;        var points=new Array();        function drawScreen () {            if(!flag){                return false;			}            var objTop = getOffsetTop(document.getElementById("myCanvas"));//对象x位置            var objLeft = getOffsetLeft(document.getElementById("myCanvas"));//对象y位置            var mouseX = event.clientX+document.body.scrollLeft;//鼠标x位置            var mouseY = event.clientY+document.body.scrollTop;//鼠标y位置			//计算点击的相对位置            // console.log(document.documentElement.scrollTop);			var defY=$('.page-content')[0].scrollTop;            var objX = mouseX-objLeft;            var objY = mouseY-objTop+defY;            if(testflag){                console.log(rayCasting({'x':objX,'y':objY},points));                return false;            }            // console.log(defY);            clickObjPosition = objX + "," + objY + ';'+mouseX+"," +mouseY;            console.log(clickObjPosition);            ctx.beginPath();            var objBool =  (JSON.stringify(startPoint) == "{}");            console.log(objBool);			if(!startPoint||objBool){                startPoint={'x':objX,'y':objY};                points.push(startPoint);                ctx.moveTo(objX, objY);                ctx.lineTo(objX+3,objY);                ctx.stroke();                tmpPoint={'x':objX+3,'y':objY};                return false;			}			else{                ctx.moveTo(tmpPoint.x, tmpPoint.y);                ctx.lineTo(objX, objY);                ctx.stroke();                tmpPoint={'x':objX,'y':objY};                points.push(tmpPoint);                return false;			}            // alert(clickObjPosition);            // console.log(clickObjPosition);            // console.log(startPoint);        }        function getOffsetTop(obj){            var tmp = obj.offsetTop;            var val = obj.offsetParent;            while(val != null){                tmp += val.offsetTop;                val = val.offsetParent;            }            return tmp;        }        function getOffsetLeft(obj){            var tmp = obj.offsetLeft;            var val = obj.offsetParent;            while(val != null){                tmp += val.offsetLeft;                val = val.offsetParent;            }            return tmp;        }        /**         * @description 射线法判断点是否在多边形内部         * @param {Object} p 待判断的点，格式：{ x: X坐标, y: Y坐标 }         * @param {Array} poly 多边形顶点，数组成员的格式同 p         * @return {String} 点 p 和多边形 poly 的几何关系         */        function rayCasting(p, poly) {            var px = p.x,                py = p.y,                flag = false;            for(var i = 0, l = poly.length, j = l - 1; i < l; j = i, i++) {                var sx = poly[i].x,                    sy = poly[i].y,                    tx = poly[j].x,                    ty = poly[j].y;                // 点与多边形顶点重合                if((sx === px && sy === py) || (tx === px && ty === py)) {                    return 'on'                }                // 判断线段两端点是否在射线两侧                if((sy < py && ty >= py) || (sy >= py && ty < py)) {                    // 线段上与射线 Y 坐标相同的点的 X 坐标                    var x = sx + (py - sy) * (tx - sx) / (ty - sy);                    // 点在多边形的边上                    if(x === px) {                        return 'on'                    }                    // 射线穿过多边形的边界                    if(x > px) {                        flag = !flag                    }                }            }            // 射线穿过多边形边界的次数为奇数时点在多边形内            return flag ? 'in' : 'out'        }	</script></block>